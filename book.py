# Import c·∫•u tr√∫c d·ªØ li·ªáu, c√°c th∆∞ vi·ªán v√† c√°c h√†m ch·ª©c nƒÉngnƒÉng
from data_structures import HashTable, merge_sort, print_wrapped_table, yes_no
from test_condition import test_book
from main import connect
import csv
import sqlite3
# K·∫øt n·ªëi ƒë·∫øn c∆° s·ªü d·ªØ li·ªáu SQLite
connected, conn, cursor = connect()

# H√†m g·ªçi l·∫°i book_management
def call_book_management():
    from menu import book_management
    book_management()
# H√†m khai b√°o ƒë·ªëi t∆∞·ª£ng Book
class Book:
    def __init__(self, isbn, title, genre, author, added_quantity, quantity, available_quantity, borrowed_quantity):
        self.isbn = isbn                                    # M√£ ISBN
        self.title = title                                  # Ti√™u ƒë·ªÅ 
        self.genre = genre                                  # Th·ªÉ lo·∫°i
        self.author = author                                # T√°c gi·∫£
        self.added_quantity = added_quantity                # S·ªë l∆∞·ª£ng s√°ch ƒë∆∞·ª£c nh·∫≠p g·∫ßn ƒë√¢y nh·∫•t
        self.quantity = quantity                            # T·ªïng s·ªë l∆∞·ª£ng s√°ch ƒë√£ nh·∫≠p
        self.available_quantity = available_quantity        # S·ªë l∆∞·ª£ng s√°ch c√≤n
        self.borrowed_quantity = borrowed_quantity          # S·ªë l∆∞·ª£ng s√°ch ƒë√£ m∆∞·ª£n
    
    # H√†m ƒë·ªãnh d·∫°ng khi in Book
    def __str__(self):
        return f"{self.isbn} | {self.title} | {self.genre}| {self.author} | {self.added_quantity} | {self.quantity} | {self.available_quantity} | {self.borrowed_quantity}"

    # H√†m ki·ªÉm tra s√°ch c√≥ tr√πng isbn, ƒë·∫£m b·∫£o isbn l√† duy nh·∫•t
    def __eq__(self, other):
        return isinstance(other, Book) and self.isbn == other.isbn

    # H√†m n√†y tr·∫£ v·ªÅ gi√° tr·ªã bƒÉm c·ªßa thu·ªôc t√≠nh isbn c·ªßa ƒë·ªëi t∆∞·ª£ng s√°ch.
    def __hash__(self):
        return hash(self.isbn)
    
# G√°n book_table d√πng c·∫•u tr√∫c d·ªØ li·ªáu HashTable
book_table = HashTable()

# Khai b√°o headers v√† k√≠ch th∆∞·ªõc c·ªôt khi in k·∫øt qu·∫£ danh s√°ch c√°c s√°ch
headers = [
    "ISBN", "Ti√™u ƒë·ªÅ", "Th·ªÉ lo·∫°i", "T√°c gi·∫£",
    "SL nh·∫≠p g·∫ßn ƒë√¢y", "SL t·ªïng", "SL c√≤n", "SL ƒë√£ m∆∞·ª£n"
]
col_widths = [9, 25, 10, 10, 15, 15, 15, 10]

# H√†m ch·ªçn thu·ªôc t√≠nh khi x·ª≠ l√Ω c√°c t√≠nh nƒÉng
def key_choice(ch):
    key_choice_1 = "1. Theo ISBN"
    key_choice_2 = "2. Theo ti√™u ƒë·ªÅ s√°ch"
    key_choice_3 = "3. Theo th·ªÉ lo·∫°i s√°ch"
    key_choice_4 = "4. Theo t√°c gi·∫£ s√°ch"
    # In ph∆∞∆°ng th·ª©c theo l·ª±a ch·ªçn t√≠nh nƒÉng
    if ch == "2":
        print("Ch·ªçn ph∆∞∆°ng th·ª©c x√≥a s√°ch:")
        print(key_choice_1, key_choice_2 , sep = "\n")
    elif ch == "3":
        print("Ch·ªçn ph∆∞∆°ng th·ª©c t√¨m ki·∫øm s√°ch:")
        print(key_choice_1, key_choice_2, key_choice_3, key_choice_4, sep = "\n")
    elif ch == "4":
        print("C·∫≠p nh·∫≠t s√°ch theo: ",key_choice_1)
    elif ch == "5":
        print("Ch·ªçn ph∆∞∆°ng th·ª©c s·∫Øp x·∫øp s√°ch:")
        print(key_choice_1, key_choice_2, key_choice_3, key_choice_4, sep = "\n")
    # Ch·ªçn thu·ªôc t√≠nh
    if ch == "4":
        key = "1"
    else:
        key = input("üëâ Nh·∫≠p l·ª±a ch·ªçn c·ªßa b·∫°n (1-4): ").strip()
    if ch == "5":
        return key, None
    if key == "1":
        key_data = input("‚úçÔ∏è Nh·∫≠p ISBN s√°ch: ").strip()
    elif key == "2":
        key_data = input("‚úçÔ∏è Nh·∫≠p ti√™u ƒë·ªÅ s√°ch: ").strip()
    elif key == "3":
        key_data = input("‚úçÔ∏è Nh·∫≠p th·ªÉ lo·∫°i s√°ch: ").strip()
    elif key == "4":
        key_data = input("‚úçÔ∏è Nh·∫≠p t√°c gi·∫£ s√°ch: ").strip()
    else:
        return None, None 
    return key, key_data # Tr·∫£ v·ªÅ key (ch·ª©a thu·ªôc t√≠nh) v√† key_data (ch·ª©a th√¥ng tin thu·ªôc t√≠nh)

def book_menu_no_key(ch):
    if ch == "1":  
        add_book()
    elif ch == "6":
        print("‚úÖ Danh s√°ch c√°c s√°ch hi·ªán t·∫°i")
        books = book_table.get_all_values()
        books_print = []
        for book in books:
            books_print.append(list(book.__dict__.values()))
        print_wrapped_table(headers, books_print, col_widths)
    elif ch == "7":
        export_to_csv()
    elif ch == "8":
        print("üè† Tr·ªü v·ªÅ menu ch√≠nh.")
        return True  # Tr·∫£ v·ªÅ True ƒë·ªÉ bi·ªÉu th·ªã k·∫øt th√∫c
    return False

def book_menu_with_key(ch, key, key_data):
    if ch == "2" and key_data is not None:
        delete_book(key, key_data)
    elif ch == "3" and key_data is not None:
        search_book(key, key_data)
    elif ch == "4" and key_data is not None:
        update_book(key, key_data)
    elif ch == "5":
        sort_books(key)
    return True

# H√†m ch·ªçn ch·ª©c nƒÉng trong qu·∫£n l√Ω s√°ch
def book_choice():
    ch = input("üëâ Nh·∫≠p l·ª±a ch·ªçn c·ªßa b·∫°n (1 - 8): ")
    while True:
        if ch not in map(str, range(1, 9)):         
            print("‚ùå L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá, vui l√≤ng th·ª≠ l·∫°i.")
            ch = input("üëâ Nh·∫≠p l·ª±a ch·ªçn c·ªßa b·∫°n (1 - 8): ")
            continue
        
        if ch in ["1", "6", "7", "8"]:
            should_break = book_menu_no_key(ch)
            if should_break:
                return True
            else:
                return False
        else:
            key, key_data = key_choice(ch)
            success = book_menu_with_key(ch, key, key_data)
            if success:
                break
    return True

def save_book_database(isbn, title, genre, author, added_quantity, quantity, available_quantity, borrowed_quantity):
    is_valid, message = test_book(isbn, title, genre, author, added_quantity, quantity, available_quantity, borrowed_quantity)
    if is_valid: 
        book = Book(isbn, title, genre, author, added_quantity, quantity, available_quantity, borrowed_quantity)
        if not book_table.search(isbn):
            book_table.insert(book.isbn,book)
            print(f"‚úÖ S√°ch '{title}' ƒë√£ ƒë∆∞·ª£c th√™m th√†nh c√¥ng.")
            cursor.execute("""
        INSERT INTO books (isbn, title, genre, author, added_quantity, quantity, available_quantity, borrowed_quantity)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    """, (isbn, title, genre, author, added_quantity, quantity, available_quantity, borrowed_quantity))
            conn.commit()
        else:
            print(f"‚ùå S√°ch v·ªõi ISBN '{isbn}' ƒë√£ l∆∞u th·∫•t b·∫°i.")
            return
    else:
        print(f"‚ùå L·ªói: {message}")
        return
    
# H√†m th√™m s√°ch t·ª´ file        
def add_book_file():
    filename = input("‚úçÔ∏è Nh·∫≠p t√™n file (VD: books.csv): ").strip()
    try:
        with open(filename, newline='', encoding='utf-8-sig') as csvfile:
            books = csv.DictReader(csvfile)
            for row in books:
                isbn = row["ISBN"]
                title = row["Ti√™u ƒë·ªÅ"]
                genre = row["Th·ªÉ lo·∫°i"]
                author = row["T√°c gi·∫£"]
                added_quantity = int(row["SL nh·∫≠p g·∫ßn ƒë√¢y nh·∫•t"])
                quantity = int(row["SL t·ªïng"])
                available_quantity = int(row["SL s√°ch c√≤n"])
                borrowed_quantity = int(row["SL s√°ch ƒë√£ m∆∞·ª£n"])
                save_book_database(isbn, title, genre, author, added_quantity, quantity, available_quantity, borrowed_quantity)
    except FileNotFoundError:
        print(f"‚ùå Kh√¥ng t√¨m th·∫•y file '{filename}'")
        return 
    except Exception as e:
        print(f"‚ùå L·ªói khi th√™m s√°ch t·ª´ file: {e}")
        return

# H√†m th√™m s√°ch t·ª´ m√†n h√¨nh
def add_book_terminal():
    isbn = input("‚úçÔ∏è  Nh·∫≠p ISBN: ").strip()
    title = input("‚úçÔ∏è Nh·∫≠p ti√™u ƒë·ªÅ s√°ch: ").strip()
    genre = input("‚úçÔ∏è Nh·∫≠p th·ªÉ lo·∫°i s√°ch: ").strip()
    author = input("‚úçÔ∏è Nh·∫≠p t√°c gi·∫£: ").strip()
    added_quantity = input("‚úçÔ∏è Nh·∫≠p t·ªïng s·ªë l∆∞·ª£ng s√°ch l∆∞u tr·ªØ: ")
    borrowed_quantity = input("‚úçÔ∏è Nh·∫≠p s·ªë l∆∞·ª£ng s√°ch ƒë√£ ƒë∆∞·ª£c m∆∞·ª£n (n·∫øu s√°ch ƒë√£ t·ªìn t·∫°i nh∆∞ng ch∆∞a ƒë∆∞a v√†o h·ªá th·ªëng, n·∫øu ch∆∞a c√≥ th√¨ ƒë·ªÉ tr·ªëng, m·∫∑c ƒë·ªãnh l√† 0): ").strip()
    try:
        added_quantity = int(added_quantity)
        quantity = added_quantity
        if borrowed_quantity == "":
            borrowed_quantity = 0
        borrowed_quantity = int(borrowed_quantity)
        available_quantity = int(quantity - borrowed_quantity)
        save_book_database(isbn, title, genre, author, added_quantity, quantity, available_quantity, borrowed_quantity)
    except Exception as e:
        print(f"‚ùå L·ªói do: {e}")
        return
# H√†m th√™m s√°ch
def add_book():
    print("Ch·ªçn ph∆∞∆°ng th·ª©c th√™m s√°ch:")
    print("1. Th√™m s√°ch t·ª´ file")
    print("2. Th√™m s√°ch t·ª´ b√†n ph√≠m")
    print("3. Tr·ªü v·ªÅ menu ch√≠nh")
    while True:
        choice = input("üëâ Nh·∫≠p l·ª±a ch·ªçn c·ªßa b·∫°n (1 - 3): ")
        if choice == "1":
            add_book_file()
        elif choice == "2":
            add_book_terminal()        
        elif choice == "3":
            break
        else:
            print("‚ùå L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá, vui l√≤ng th·ª≠ l·∫°i.")

# H√†m x√≥a s√°ch
def delete_book(key, key_data):
    book_to_delete = None
    if key == "1":
        isbn_to_delete = key_data.strip()
        book_to_delete = book_table.search(isbn_to_delete)
        if not book_to_delete:
            print("‚ùå Kh√¥ng t√¨m th·∫•y s√°ch v·ªõi ISBN n√†y.")
    elif key == "2":
        title_to_delete = key_data.strip()
        matching_books = []
        all_books = book_table.get_all_values()
        for book in all_books:
            if book.title.lower() == title_to_delete.lower(): # So s√°nh kh√¥ng ph√¢n bi·ªát hoa th∆∞·ªùng
                matching_books.append(book)
        if not matching_books:
            print(f"‚ùå Kh√¥ng t√¨m th·∫•y s√°ch v·ªõi ti√™u ƒë·ªÅ '{title_to_delete}'.")
        elif len(matching_books) == 1:
            book_to_delete = matching_books[0]
            print(f"‚úÖ T√¨m th·∫•y 1 s√°ch: '{book_to_delete.title}' (ISBN: {book_to_delete.isbn}).")
            confirm = input("B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a s√°ch n√†y? (y/n): ").strip().lower()
            if confirm != 'y':
                print("H·ªßy x√≥a s√°ch.")
                if not yes_no():
                    call_book_management()
                return # Tho√°t kh·ªèi h√†m delete_book
        else:
            print(f"‚úÖ T√¨m th·∫•y nhi·ªÅu s√°ch v·ªõi ti√™u ƒë·ªÅ '{title_to_delete}':")
            display_data = []
            for b in matching_books:
                display_data.append([b.isbn, b.title, b.genre, b.author, b.added_quantity, b.quantity, b.available_quantity, b.borrowed_quantity])
            print_wrapped_table(headers, display_data, col_widths)
            
            isbn_to_select = input("Vui l√≤ng nh·∫≠p ISBN c·ªßa cu·ªën s√°ch c·ª• th·ªÉ b·∫°n mu·ªën x√≥a t·ª´ danh s√°ch tr√™n: ").strip()
            book_to_delete = book_table.search(isbn_to_select)
            # Ki·ªÉm tra l·∫°i xem ISBN nh·∫≠p v√†o c√≥ thu·ªôc danh s√°ch c√°c s√°ch c√≥ c√πng ti√™u ƒë·ªÅ kh√¥ng
            if not book_to_delete or book_to_delete.title.lower() != title_to_delete.lower():
                print(f"‚ùå ISBN '{isbn_to_select}' kh√¥ng h·ª£p l·ªá ho·∫∑c kh√¥ng kh·ªõp v·ªõi s√°ch c√≥ ti√™u ƒë·ªÅ '{title_to_delete}'.")
                book_to_delete = None # ƒê·∫£m b·∫£o kh√¥ng x√≥a nh·∫ßm
    else:
        print("‚ùå L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá. Vui l√≤ng ch·ªçn 1 ho·∫∑c 2.")
        if not yes_no():
            call_book_management()

    # Ti·∫øn h√†nh x√≥a n·∫øu t√¨m th·∫•y s√°ch v√† kh√¥ng c√≥ l·ªói
    if book_to_delete:
        if book_to_delete.borrowed_quantity > 0:
            print(f"‚ùå S√°ch '{book_to_delete.title}' (ISBN: {book_to_delete.isbn}) hi·ªán ƒëang c√≥ {book_to_delete.borrowed_quantity} b·∫£n ƒëang ƒë∆∞·ª£c m∆∞·ª£n. Kh√¥ng th·ªÉ x√≥a s√°ch n√†y khi c√≤n b·∫£n ƒëang m∆∞·ª£n.")
        else:
            book_table.delete(book_to_delete.isbn)
            try:
                cursor.execute("DELETE FROM books WHERE isbn = ?", (book_to_delete.isbn,))
                conn.commit()
                print("‚úÖ X√≥a s√°ch th√†nh c√¥ng.")
            except sqlite3.Error as e:
                print(f"‚ùå L·ªói khi x√≥a s√°ch kh·ªèi c∆° s·ªü d·ªØ li·ªáu: {e}")
    
    if not yes_no():
        call_book_management()
    else:
        key, key_data = key_choice("2")
        book_menu_with_key("2", key, key_data)
    
# H√†m t√¨m ki·∫øm s√°ch
def search_book(key, key_data):
    keyword = key_data.strip().lower()
    result = []
    for book in book_table.get_all_values():
        if key == "1" and keyword in book.isbn.lower():
            result.append(list(book.__dict__.values()))
        elif key == "2" and keyword in book.title.lower():
            result.append(list(book.__dict__.values()))
        elif key == "3" and keyword in book.genre.lower():
            result.append(list(book.__dict__.values()))
        elif key == "4" and keyword in book.author.lower():
            result.append(list(book.__dict__.values()))
    if len(result) >= 1:
        print("\n ‚úÖK·∫øt qu·∫£ t√¨m ki·∫øm:")
        print_wrapped_table(headers, result, col_widths)
    else:
        print("‚ùå Kh√¥ng t√¨m th·∫•y s√°ch n√†o.")
    if not yes_no():
        call_book_management()
    else:
        key, key_data = key_choice("3")
        book_menu_with_key("3", key, key_data)
# H√†m c·∫≠p nh·∫≠t s√°ch
def update_book(key, key_data):
    book = book_table.search(key_data)
    if not book:
        print("‚ùå Kh√¥ng t√¨m th·∫•y s√°ch ƒë·ªÉ c·∫≠p nh·∫≠t.")
        return
    print("Th√¥ng tin s√°ch hi·ªán t·∫°i:")
    print_wrapped_table(headers, [list(book.__dict__.values())], col_widths)
    print("‚úçÔ∏è Nh·∫≠p th√¥ng tin m·ªõi (ƒë·ªÉ tr·ªëng n·∫øu kh√¥ng mu·ªën thay ƒë·ªïi):")
    new_title = input(f"Ti√™u ƒë·ªÅ [{book.title}]: ").strip() or book.title
    new_genre = input(f"Th·ªÉ lo·∫°i [{book.genre}]: ").strip() or book.genre
    new_author = input(f"T√°c gi·∫£ [{book.author}]: ").strip() or book.author
    new_added_quantity = input(f"Nh·∫≠p th√™m s·ªë l∆∞·ª£ng s√°ch [{book.added_quantity}]: ").strip() or book.added_quantity
    new_borrowed_quantity = input(f"S·ªë l∆∞·ª£ng s√°ch ƒë√£ m∆∞·ª£n [{book.borrowed_quantity}]: ").strip() or book.borrowed_quantity
    try:
        new_added_quantity = int(new_added_quantity)
        new_borrowed_quantity = int(new_borrowed_quantity)
        is_valid, message = test_book(book.isbn, new_title, new_genre, new_author, int(new_added_quantity), book.quantity, book.available_quantity, int(new_borrowed_quantity))
        if is_valid:
            book.title = new_title
            book.genre = new_genre
            book.author = new_author
            book.added_quantity = int(new_added_quantity)
            book.borrowed_quantity = int(new_borrowed_quantity)
            book.quantity += book.added_quantity
            book.available_quantity = book.quantity - book.borrowed_quantity
            book_table.insert(book.isbn, book)
            cursor.execute("""
        UPDATE books
        SET title = ?, genre = ?, author = ?, added_quantity = ?, quantity = ?, available_quantity = ?, borrowed_quantity = ?
        WHERE isbn = ?
    """, (book.title, book.genre, book.author, book.added_quantity, book.quantity, book.available_quantity, book.borrowed_quantity, book.isbn))
            conn.commit()
            print("‚úÖ C·∫≠p nh·∫≠t s√°ch th√†nh c√¥ng.")
        else:
            print(f"‚ùå L·ªói: {message}")
    except Exception as e:
        print(f"‚ùå L·ªói do {e}")
    if not yes_no():
        call_book_management()
    else:
        key, key_data = key_choice("4")
        book_menu_with_key("4", key, key_data)
# H√†m s·∫Øp x·∫øp s√°ch
def sort_books(key):
    books = book_table.get_all_values()
    reverse = input("B·∫°n mu·ªën s·∫Øp x·∫øp theo th·ª© t·ª± tƒÉng d·∫ßn (True / False)?")
    if reverse.lower() == "true":
        reverse = False
    else:
        reverse = True
    if key == "1":
        key_func = lambda book: book.isbn
    elif key == "2" :
        key_func = lambda book: book.title
    elif key == "3":
        key_func = lambda book: book.genre
    elif key == "4":
        key_func = lambda book: book.author
    sorted_books = merge_sort(books, key_func, reverse)
    print("\n ‚úÖ Danh s√°ch s√°ch sau khi s·∫Øp x·∫øp:")
    books_print = []
    for book in sorted_books:
        books_print.append(list(book.__dict__.values()))
    print_wrapped_table(headers, books_print, col_widths)
    if not yes_no():
        call_book_management()
    else:
        key, key_data = key_choice("5")
        book_menu_with_key("5", key, key_data)
# H√†m xu·∫•t file csv
def export_to_csv():
    try:
        with open("books_export.csv", "w", newline="", encoding="utf-8-sig") as f:
            writer = csv.writer(f)
            writer.writerow(["ISBN", "Ti√™u ƒë·ªÅ", "Th·ªÉ lo·∫°i", "T√°c gi·∫£", "SL nh·∫≠p g·∫ßn ƒë√¢y nh·∫•t", "SL t·ªïng", "SL s√°ch c√≤n", "SL s√°ch ƒë√£ m∆∞·ª£n"])
            for book in book_table.get_all_values():
                writer.writerow([book.isbn, book.title, book.genre, book.author, book.added_quantity, book.quantity, book.available_quantity, book.borrowed_quantity])
        print("‚úÖ Xu·∫•t CSV", "ƒê√£ l∆∞u file books_export.csv")
    except Exception as e:
        print("‚ùå L·ªói do {e}")
